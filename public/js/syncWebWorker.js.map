{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/types/index.ts","webpack:///./src/workers/sync/index.ts","webpack:///./src/workers/sync/tasks/BaseTask.ts","webpack:///./src/types/search.ts","webpack:///./src/types/testing.ts","webpack:///./src/types/syncerTasks.ts","webpack:///./src/types/syncerResponses.ts","webpack:///./src/workers/sync/tasks/index.ts","webpack:///./src/workers/sync/tasks/ExtendSheetTask.ts","webpack:///./src/workers/sync/syncWebWorker.ts","webpack:///./src/workers/sync/typeGuards.ts","webpack:///./src/workers/sync/syncResponses.ts","webpack:///./src/workers/sync/tasks/GetRowsTask.ts","webpack:///./src/workers/sync/tasks/GetSheetsTask.ts","webpack:///./src/workers/sync/tasks/UpdateRowTask.ts","webpack:///./src/workers/sync/tasks/DeleteRowTask.ts","webpack:///./src/workers/sync/tasks/GetSpreadsheetTask.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","SyncerError","Error","errorMsg","friendlyMsg","needsReAuth","super","payload","testMode","type","SyncerPayloadType","GET_ROWS","createGetRowsTask","GET_SPREADSHEET","createGetSpreadsheetTask","GET_SHEETS","createGetSheetsTask","DELETE_ROW","createDeleteRowTask","UPDATE_ROW","createUpdateRowTask","TestMode","OFF","this","undefined","SearchType","SyncerResponseType","SyncerState","ExtendSheetTask","BaseTask","token","url","URL","spreadsheetId","opts","method","cache","headers","Authorization","body","JSON","stringify","requests","appendDimension","sheetId","dimension","length","response","fetch","toString","ok","error","json","status","paused","taskFactory","TaskFactory","state","SYNCED","parallelQueue","Map","seriesQueue","workSeriesQueueTasks","id","task","work","postMessage","shift","workParallelQueueTasks","size","entries","console","log","delete","then","catch","set","sleep","ms","Promise","resolve","setTimeout","postQueueState","e","instanceOfSyncerError","postReAuthRequest","PAUSED","postError","message","sync","onmessage","msg","data","TEST_MODE_UPDATE","AUTH_UPDATE","UNPAUSE","createTask","async","push","prequeue","postResponse","SYNCER_STATE","ERROR","REAUTH","GetRowsTask","MockGetRowsTask","range","sheetTitle","rows","values","map","row","_token","FAIL_GET_RANGE","RETURN_ROWS","GetSheetsTask","sheets","UpdateRowTask","idx","params","valueInputOption","keys","forEach","searchParams","append","majorDimension","content","includes","extendSheetTask","EXTEND_SHEET","DeleteRowTask","startRowIndex","endRowIndex","startColumnIndex","deleteRange","shiftDimension","GetSpreadsheetTask","spreadsheet"],"mappings":"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","file":"syncWebWorker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 42);\n","export * from \"./caret\"\nexport * from \"./errors\"\nexport * from \"./search\"\nexport * from \"./testing\"\nexport * from \"./syncerTasks\"\nexport * from \"./syncerResponses\"\n","export * from \"./typeGuards\"\nexport * from \"./syncWebWorker\"\nexport * from \"./syncResponses\"\n\n// TODO: see if this can be moved\nexport class SyncerError extends Error {\n    constructor(errorMsg: string, public friendlyMsg: string, public needsReAuth: boolean) {\n        super(errorMsg)\n    }\n}\n","import { SyncerTaskPayload, TestMode, SyncerPayloadType } from \"../../../types\"\nimport {\n    createGetRowsTask, createGetSpreadsheetTask, createGetSheetsTask,\n    createDeleteRowTask, createUpdateRowTask\n} from \".\"\n\nexport class TaskFactory {\n    public createTask(payload: SyncerTaskPayload, testMode: TestMode): BaseTask<SyncerTaskPayload> | undefined {\n        switch(payload.type) {\n            case SyncerPayloadType.GET_ROWS:\n                return createGetRowsTask(payload, testMode)\n            case SyncerPayloadType.GET_SPREADSHEET:\n                return createGetSpreadsheetTask(payload, testMode)\n            case SyncerPayloadType.GET_SHEETS:\n                return createGetSheetsTask(payload, testMode)\n            case SyncerPayloadType.DELETE_ROW:\n                return createDeleteRowTask(payload, testMode)\n            case SyncerPayloadType.UPDATE_ROW:\n                return createUpdateRowTask(payload, testMode)\n            // case SyncerPayloadType.CREATE_ROW:\n            //     return undefined // TODO\n            // case SyncerPayloadType.MOVE_ROW:\n            //     return undefined // TODO\n            default:\n                return undefined\n        }\n        return\n    }\n\n}\n\nexport abstract class BaseTask<P extends SyncerTaskPayload> {\n    public payload: P\n    public async: boolean | undefined\n    public testMode: TestMode = TestMode.OFF\n\n    constructor(payload: P, testMode?: TestMode) {\n        this.payload = payload\n        this.testMode = (testMode !== undefined) ? testMode : this.testMode\n    }\n\n    public abstract work(token: string): Promise<P>\n}\n","export enum SearchType {\n    NONE,\n    AND,\n    OR,\n}\n","export enum TestMode {\n    OFF = \"0\",\n    WORKING = \"1\",\n    FAIL_GET_SPREADSHEET_SHEETS = \"2\",\n    FAIL_GET_RANGE = \"3\",\n    FAIL_UPDATE_RANGE = \"4\",\n    FAIL_DELETE_ROW = \"5\",\n    RETURN_ROWS = \"6\",\n    DEMO = \"7\"\n}\n","import { TestMode } from \"./testing\"\n\nexport type SyncerTaskPayload = (\n    GetRowsPayload | GetSheetsPayload | GetSpreadsheetPayload | UpdateRowPayload |\n    ExtendSheetPayload | DeleteRowPayload | TestModeUpdatePayload | AuthUpdatePayload |\n    UnpausePayload\n)\n\nexport enum SyncerPayloadType {\n    AUTH_UPDATE,\n    DELETE_ROW,\n    UPDATE_ROW,\n    GET_ROWS,\n    GET_SHEETS,\n    TEST_MODE_UPDATE,\n    UNPAUSE,\n    GET_SPREADSHEET,\n    EXTEND_SHEET,\n    CREATE_ROW,\n    MOVE_ROW,\n}\n\nexport interface TestModeUpdatePayload {\n    type: SyncerPayloadType.TEST_MODE_UPDATE\n    testMode: TestMode\n}\n\nexport interface AuthUpdatePayload {\n    type: SyncerPayloadType.AUTH_UPDATE\n    token: string\n}\n\nexport interface UnpausePayload {\n    type: SyncerPayloadType.UNPAUSE\n}\n\nexport interface DeleteRowPayload {\n    type: SyncerPayloadType.DELETE_ROW\n    idx: number\n    spreadsheetId: string\n    sheetId: number\n}\n\nexport interface ExtendSheetPayload {\n    type: SyncerPayloadType.EXTEND_SHEET\n    spreadsheetId: string\n    sheetId: number\n}\n\nexport interface UpdateRowPayload {\n    type: SyncerPayloadType.UPDATE_ROW\n    idx: number\n    spreadsheetId: string\n    sheetId: number\n    sheetTitle: string\n    content: string\n}\n\nexport interface GetSpreadsheetPayload {\n    type: SyncerPayloadType.GET_SPREADSHEET\n    spreadsheetId: string\n    spreadsheet?: gapi.client.sheets.Spreadsheet\n}\n\nexport interface GetRowsPayload {\n    type: SyncerPayloadType.GET_ROWS\n    spreadsheetId: string\n    sheetId: number\n    sheetTitle: string\n    rows: string[]\n}\n\nexport interface GetSheetsPayload {\n    type: SyncerPayloadType.GET_SHEETS\n    spreadsheetId: string\n    sheets: gapi.client.sheets.Sheet[]\n}\n","import { SyncerError } from \"../workers/sync\"\n\nexport type SyncerResponse = (\n    RowsResponse | SheetsResponse | QueueStateResponse | ErrorResponse | ReauthResponse\n)\n\nexport enum SyncerResponseType {\n    ROWS,\n    SHEETS,\n    SYNCER_STATE,\n    ERROR,\n    REAUTH,\n}\n\nexport enum SyncerState {\n    PAUSED = \"cloud_off\",\n    UPLOADING = \"cloud_upload\",\n    DOWNLOADING = \"cloud_download\",\n    SYNCED = \"cloud_done\",\n}\n\nexport interface RowsResponse {\n    type: SyncerResponseType.ROWS\n    spreadsheetId: string\n    sheetId: number\n    rows: string[]\n}\n\nexport interface SheetsResponse {\n    type: SyncerResponseType.SHEETS\n    spreadsheetId: string\n    sheets: gapi.client.sheets.Sheet[]\n}\n\nexport interface QueueStateResponse {\n    type: SyncerResponseType.SYNCER_STATE\n    length: number\n    state: SyncerState\n}\n\nexport interface ErrorResponse {\n    type: SyncerResponseType.ERROR\n    error: SyncerError | Error\n    friendlyMsg: string\n}\n\nexport interface ReauthResponse {\n    type: SyncerResponseType.REAUTH\n}\n","export * from \"./BaseTask\"\nexport * from \"./GetRowsTask\"\n// export * from \"./MoveRowTask\"\nexport * from \"./GetSheetsTask\"\nexport * from \"./UpdateRowTask\"\nexport * from \"./ExtendSheetTask\"\nexport * from \"./DeleteRowTask\"\n// export * from \"./CreateRowTask\"\nexport * from \"./GetSpreadsheetTask\"\n","import { SyncerError } from \"..\"\nimport { BaseTask } from \"./BaseTask\"\nimport { GapiErrorResponse, ExtendSheetPayload } from \"../../../types\"\n\nexport class ExtendSheetTask<P extends ExtendSheetPayload> extends BaseTask<P> {\n    constructor(payload: P) { super(payload) }\n\n    public async work(token: string): Promise<P> {\n        let extendSheetLength = 100\n        let url = new URL(`https://sheets.googleapis.com/v4/spreadsheets/${this.payload.spreadsheetId}:batchUpdate`)\n        let headers = { Authorization: `Bearer ${token}` }\n        let body = JSON.stringify({ requests: [{ appendDimension: { sheetId: this.payload.sheetId, dimension: \"ROWS\", length: extendSheetLength } }] })\n        let opts: RequestInit = { method: \"POST\", mode: \"cors\", cache: \"no-cache\", headers: headers, body: body }\n        let response = await fetch(url.toString(), opts)\n        if (!response.ok) {\n            let error: GapiErrorResponse = await response.json()\n            throw new SyncerError(JSON.stringify(error), \"Failed to extend sheet\", response.status === 401)\n        }\n        return this.payload\n    }\n}\n","import { SyncerState, SyncerTaskPayload, TestMode, SyncerPayloadType } from \"../../types\"\nimport {\n    postQueueState, postError,\n    postReAuthRequest, instanceOfSyncerError, SyncerError\n} from \".\"\nimport { TaskFactory, BaseTask } from \"./tasks\"\n\nconst syncRate = 250 // ms\nlet paused: boolean = false\nlet testMode: TestMode = TestMode.OFF\nconst taskFactory = new TaskFactory()\nlet token: string | undefined = undefined\nlet state: SyncerState = SyncerState.SYNCED\nconst parallelQueue: Map<string, BaseTask<SyncerTaskPayload>> = new Map()\nconst seriesQueue: { id: string, task: BaseTask<SyncerTaskPayload> }[] = []\n\nsync()\nonmessage = (msg) => prequeue(msg)\n\nfunction prequeue(msg: MessageEvent) {\n    const { id, payload }: { id: string, payload: SyncerTaskPayload } = msg.data\n\n    if (payload.type === SyncerPayloadType.TEST_MODE_UPDATE) {\n        testMode = payload.testMode\n        if (testMode !== TestMode.OFF) {\n            token = \"mock\"\n        }\n        return\n    } else if (payload.type === SyncerPayloadType.AUTH_UPDATE) {\n        token = payload.token\n        return\n    } else if (payload.type === SyncerPayloadType.UNPAUSE) {\n        paused = false\n        return\n    }\n\n    let task = taskFactory.createTask(payload, testMode)\n    if (task === undefined) {\n        return\n    }\n\n\n    if (task.async) {\n        parallelQueue.set(id, task)\n    } else {\n        seriesQueue.push({ id, task })\n    }\n}\n\nasync function sync() {\n    while (true) {\n        await sleep(syncRate)\n        if (!paused && state !== SyncerState.SYNCED && seriesQueue.length === 0 && parallelQueue.size === 0) {\n            state = SyncerState.SYNCED\n            postQueueState(seriesQueue.length, state)\n        }\n        try {\n            workParallelQueueTasks()\n            await workSeriesQueueTasks()\n        } catch (e) {\n            if (instanceOfSyncerError(e) && e.needsReAuth) {\n                postReAuthRequest()\n                token = undefined\n            } else {\n                paused = true\n                state = SyncerState.PAUSED\n                postQueueState(seriesQueue.length, state)\n                postError((instanceOfSyncerError(e))\n                    ? e\n                    : new SyncerError(e.message, \"Unknown Error\", false))\n            }\n        }\n    }\n}\n\nasync function workSeriesQueueTasks() {\n    while (seriesQueue.length !== 0 && token && !paused) {\n        let { id, task } = seriesQueue[0]\n        let payload = await task.work(token)\n        postMessage({ id, payload })\n        seriesQueue.shift()\n    }\n}\n\nfunction workParallelQueueTasks() {\n    if (parallelQueue.size === 0 || !token || paused) {\n        return\n    }\n    for (let [id, task] of parallelQueue.entries()) {\n        console.log(`About to work task ${id}`)\n        parallelQueue.delete(id)\n        task.work(token).then((payload: SyncerTaskPayload) => {\n            postMessage({ id, payload })\n        }).catch((error: Error) => {\n            parallelQueue.set(id, task)\n            throw error\n        })\n    }\n}\n\nfunction sleep(ms: number) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n","import { SyncerError } from \".\"\n\nexport function instanceOfSyncerError(error: Error | SyncerError): error is SyncerError {\n    return \"needsReAuth\" in error\n}\n","import { SyncerError } from \".\"\nimport { \n    SyncerResponse, SyncerResponseType, SyncerState\n} from \"../../types\"\n\n// TODO: convert these to use new pattern\n\nexport function postQueueState(length: number, state: SyncerState) {\n    postResponse({\n        length: length,\n        state: state,\n        type: SyncerResponseType.SYNCER_STATE\n    })\n}\n\nexport function postError(error: SyncerError) {\n    postResponse({\n        friendlyMsg: error.friendlyMsg,\n        error: error,\n        type: SyncerResponseType.ERROR\n    })\n}\n\nexport function postReAuthRequest() {\n    postMessage({ type: SyncerResponseType.REAUTH })\n}\n\nfunction postResponse(response: SyncerResponse) {\n    postMessage(response)\n}\n","import { SyncerError } from \"..\"\nimport { BaseTask } from \"./BaseTask\"\nimport { GapiErrorResponse, GetRowsPayload, TestMode } from \"../../../types\"\n\nexport function createGetRowsTask<P extends GetRowsPayload>(payload: P, testMode: TestMode): BaseTask<P> {\n    return (testMode === TestMode.OFF)\n        ? new GetRowsTask(payload)\n        : new MockGetRowsTask(payload, testMode)\n}\n\nexport class GetRowsTask<P extends GetRowsPayload> extends BaseTask<P> {\n    constructor(payload: P) {\n        super(payload)\n        this.async = true\n    }\n\n    public async work(token: string): Promise<P> {\n        let range = `${this.payload.sheetTitle}!A:A`\n        let url = `https://sheets.googleapis.com/v4/spreadsheets/${this.payload.spreadsheetId}/values/${range}`\n        let headers = { Authorization: `Bearer ${token}` }\n        let opts: RequestInit = { method: \"GET\", cache: \"no-cache\", headers: headers }\n        let response = await fetch(url, opts)\n        if (!response.ok) {\n            let error: GapiErrorResponse = await response.json()\n            throw new SyncerError(\n                JSON.stringify(error),\n                `Failed to get sheet rows: ${range}`,\n                response.status === 401)\n        } else {\n            let data: gapi.client.sheets.ValueRange = await response.json()\n            this.payload.rows = (data.values) ? data.values.map(row => row[0]) : []\n        }\n        return this.payload\n    }\n}\n\nexport class MockGetRowsTask<P extends GetRowsPayload> extends BaseTask<P> {\n    constructor(payload: P, testMode: TestMode) {\n        super(payload, testMode)\n        this.async = true\n    }\n\n    public async work(_token: string): Promise<P> {\n        if (this.testMode === TestMode.FAIL_GET_RANGE) {\n            throw new Error(\"mock fail\")\n        } else if (this.testMode === TestMode.RETURN_ROWS) {\n            this.payload.rows = [\"aaa\", \"bbb\", \"ccc\", \"@tag\", \"@key:value\"]\n        }\n        return this.payload\n    }\n}\n","import { SyncerError } from \"..\"\nimport { BaseTask } from \"./BaseTask\"\nimport { GapiErrorResponse, GetSheetsPayload, TestMode } from \"../../../types\"\n\nexport function createGetSheetsTask<P extends GetSheetsPayload>(payload: P, testMode: TestMode): BaseTask<P> | undefined {\n    return (testMode === TestMode.OFF)\n        ? new GetSheetsTask(payload)\n        : undefined // new MockGetSheetsTask(payload, testMode)\n}\n\nexport class GetSheetsTask<P extends GetSheetsPayload> extends BaseTask<P> {\n    constructor(payload: P) {\n        super(payload)\n        this.async = true\n    }\n\n    public async work(token: string): Promise<P> {\n        let url = `https://sheets.googleapis.com/v4/spreadsheets/${this.payload.spreadsheetId}`\n        let headers = { Authorization: `Bearer ${token}` }\n        let opts: RequestInit = { method: \"GET\", cache: \"no-cache\", headers: headers }\n        let response = await fetch(url, opts)\n        if (!response.ok) {\n            let error: GapiErrorResponse = await response.json()\n            throw new SyncerError(\n                JSON.stringify(error),\n                `Failed to get spreadsheet details for spreadsheet: ${this.payload.spreadsheetId}`,\n                response.status === 401\n            )\n        } else {\n            let data: gapi.client.sheets.Spreadsheet = await response.json()\n            this.payload.sheets = (data.sheets) ? data.sheets : []\n        }\n        return this.payload\n    }\n}\n","import { SyncerError } from \"..\"\nimport { BaseTask } from \"./BaseTask\"\nimport { GapiErrorResponse, UpdateRowPayload, SyncerTaskPayload, TestMode, SyncerPayloadType } from \"../../../types\"\nimport { ExtendSheetTask } from \"./ExtendSheetTask\"\n\nexport function createUpdateRowTask<P extends UpdateRowPayload>(payload: P, testMode: TestMode): BaseTask<P> | undefined {\n    return (testMode === TestMode.OFF)\n        ? new UpdateRowTask(payload)\n        : undefined // new MockUpdateRowTask(payload, testMode) // TODO\n}\n\nexport class UpdateRowTask<P extends UpdateRowPayload> extends BaseTask<P> {\n    constructor(payload: P) { super(payload) }\n\n    public async work(token: string): Promise<P> {\n        let range = `${this.payload.sheetTitle}!A${this.payload.idx + 1}:A${this.payload.idx + 1}`\n        let url = new URL(`https://sheets.googleapis.com/v4/spreadsheets/${this.payload.spreadsheetId}/values/${range}`)\n        let headers = { Authorization: `Bearer ${token}` }\n        let params: Record<string, string> = { valueInputOption: \"RAW\" }\n        Object.keys(params).forEach(key => url.searchParams.append(key, params[key]))\n        let body = JSON.stringify({ range: range, majorDimension: \"ROWS\", values: [[this.payload.content]] })\n        let opts: RequestInit = { method: \"PUT\", cache: \"no-cache\", headers: headers, body: body }\n        let response = await fetch(url.toString(), opts)\n        let data = await response.json()\n        if (!response.ok) {\n            if (data.error.message.includes(\"exceeds grid limits\")) {\n                let extendSheetTask: SyncerTaskPayload = {\n                    type: SyncerPayloadType.EXTEND_SHEET,\n                    spreadsheetId: this.payload.spreadsheetId,\n                    sheetId: this.payload.sheetId\n                }\n                await new ExtendSheetTask(extendSheetTask).work(token)\n                let secondResponse = await fetch(url.toString(), opts)\n                if (!secondResponse.ok) {\n                    let error: GapiErrorResponse = await response.json()\n                    throw new SyncerError(JSON.stringify(error), `Failed to update row: ${range}`, response.status === 401)\n                } else {\n                    return this.payload\n                }\n            }\n            throw new SyncerError(JSON.stringify(data), `Failed to update row: ${range}`, response.status === 401)\n        }\n        return this.payload\n    }\n}\n","import { SyncerError } from \"..\"\nimport { BaseTask } from \"./BaseTask\"\nimport { GapiErrorResponse, DeleteRowPayload, TestMode } from \"../../../types\"\n\nexport function createDeleteRowTask<P extends DeleteRowPayload>(payload: P, testMode: TestMode): BaseTask<P> | undefined {\n    return (testMode === TestMode.OFF)\n        ? new DeleteRowTask(payload)\n        : undefined // new MockDeleteRowTask(payload, testMode) // TODO\n}\n\nexport class DeleteRowTask<P extends DeleteRowPayload> extends BaseTask<P> {\n    constructor(payload: P) { super(payload) }\n\n    public async work(token: string): Promise<P> {\n        let range = { sheetId: this.payload.sheetId, startRowIndex: this.payload.idx, endRowIndex: this.payload.idx + 1, startColumnIndex: 0 }\n        let url = new URL(`https://sheets.googleapis.com/v4/spreadsheets/${this.payload.spreadsheetId}:batchUpdate`)\n        let headers = { Authorization: `Bearer ${token}` }\n        let body = JSON.stringify({ requests: [{ deleteRange: { range: range, shiftDimension: \"ROWS\" } }] })\n        let opts: RequestInit = { method: \"POST\", cache: \"no-cache\", headers: headers, body: body }\n        let response = await fetch(url.toString(), opts)\n        if (!response.ok) {\n            let error: GapiErrorResponse = await response.json()\n            throw new SyncerError(JSON.stringify(error), `Failed to delete row: ${this.payload.idx}`, response.status === 401)\n        }\n        return this.payload\n    }\n}","import { SyncerError } from \"..\"\nimport { BaseTask } from \"./BaseTask\"\nimport { GapiErrorResponse, GetSpreadsheetPayload, TestMode } from \"../../../types\"\n\nexport function createGetSpreadsheetTask<P extends GetSpreadsheetPayload>(payload: P, testMode: TestMode): BaseTask<P> | undefined {\n    return (testMode === TestMode.OFF)\n        ? new GetSpreadsheetTask(payload)\n        : undefined // new MockGetSpreadsheetTask(payload, testMode)\n}\n\nexport class GetSpreadsheetTask<P extends GetSpreadsheetPayload> extends BaseTask<P> {\n    constructor(payload: P) {\n        super(payload)\n        this.async = true\n    }\n\n    public async work(token: string): Promise<P> {\n        let url = `https://sheets.googleapis.com/v4/spreadsheets/${this.payload.spreadsheetId}`\n        let headers = { Authorization: `Bearer ${token}` }\n        let opts: RequestInit = { method: \"GET\", cache: \"no-cache\", headers: headers }\n        let response = await fetch(url, opts)\n        if (!response.ok) {\n            let error: GapiErrorResponse = await response.json()\n            throw new SyncerError(\n                JSON.stringify(error),\n                `Failed to get spreadsheet details for spreadsheet: ${this.payload.spreadsheetId}`,\n                response.status === 401\n            )\n        } else {\n            this.payload.spreadsheet = await response.json()\n        }\n        return this.payload\n    }\n}\n"],"sourceRoot":""}